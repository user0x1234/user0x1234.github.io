---
layout: post
title: "HomeWork 3"
date: 2025-10-23
markdown: kramdown
---

## Research Topics: Theory (T)

- **T1**: RSA encryption/decryption for the letters (using very small and manageable prime numbers p,q, of course). Try to decode the message by analyzing the language's alphabet distribution. Find a good and practical algorithm for this.


# 🔐 RSA Letter Encryption, Decryption & Frequency Analysis Attack

## 🧭 Introduction

This interactive demo illustrates the **RSA cryptosystem** using **letters** (`A → 0`, `B → 1`, … `Z → 25`) instead of large integers.  
It demonstrates three main concepts:

1. **Encryption & Decryption** using small, manageable primes `p` and `q`.
2. **Factorization-based Attack**, where we exploit small numbers to recover the private key.
3. **Frequency Analysis**, where we analyze letter frequencies to validate decryption quality against English letter distribution.

> ⚠️ Note: This version uses **tiny primes** to make the math easy to see — not secure at all!  
> Real RSA uses 2048+ bit primes and padding (e.g., OAEP).

---

## 🧮 Step 1: Choose RSA Parameters

Enter two small primes `p`, `q` and a public exponent `e`.  
Click **Generate Keys** to compute:
- Modulus `n = p × q`
- Euler’s totient `φ(n) = (p − 1)(q − 1)`
- Private key `d = e⁻¹ mod φ(n)`

<input id="p" type="number" value="17" style="width:70px;"> × 
<input id="q" type="number" value="19" style="width:70px;">  
Public exponent **e**: <input id="e" type="number" value="5" style="width:70px;">  
<button onclick="generateKeys()">Generate Keys</button>

<div id="keyInfo" style="margin-top:10px;font-family:monospace;"></div>

---

## ✉️ Step 2: Encrypt a Message

Type any **letter-only message** (spaces ignored).  
Each letter is converted to a number, then encrypted as `c = m^e mod n`.

<input id="plaintext" value="HELLOWORLD" style="width:100%;padding:8px;">  
<button onclick="encrypt()">Encrypt</button>

**Ciphertext (space-separated integers):**
<pre id="cipherOut" style="background:#f5f5f5;padding:6px;"></pre>

---

## 🔓 Step 3: Decrypt or Attack

- **Decrypt** — uses your private key `(d, n)`  
- **Attack** — factors `n`, finds `d`, decrypts, and compares with English letter distribution using a **chi-squared test**

<button onclick="decrypt()">Decrypt (using private key)</button>
<button onclick="attack()">Attack (factor n & analyze frequency)</button>

**Recovered text:**
<pre id="recoverOut" style="background:#f5f5f5;padding:6px;"></pre>

---

## 📊 Step 4: Frequency Distribution Plot

The plot below compares **English letter frequencies** with the **decrypted text frequencies** to validate whether the cracked message resembles real English.

<canvas id="freqPlot" width="700" height="350"></canvas>

---

## 🧠 Discussion

RSA’s security relies on the **difficulty of factoring large composite numbers**.  
Here, because we use small primes, an attacker can:
1. Factor `n` easily (trial division),
2. Compute the private key `d`,
3. Decrypt the ciphertext directly.

Additionally, **frequency analysis** — comparing how often each letter appears — is useful for validating whether the decrypted text is meaningful English, especially if there’s ambiguity.

---

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
function egcd(a,b){if(b===0)return{g:a,x:1,y:0};const r=egcd(b,a%b);return{g:r.g,x:r.y,y:r.x-Math.floor(a/b)*r.y};}
function modInverse(a,m){const r=egcd(a,m);if(r.g!==1)return null;return (r.x%m+m)%m;}
function modPow(b,e,m){let r=1n,base=BigInt(b)%BigInt(m);e=BigInt(e);m=BigInt(m);
  while(e>0n){if(e&1n)r=(r*base)%m;base=(base*base)%m;e>>=1n;}return Number(r);}
function letterToNum(c){const n=c.toUpperCase().charCodeAt(0)-65;return(n>=0&&n<26)?n:null;}
function numToLetter(n){return String.fromCharCode(65+(n%26));}
let N,D;
function generateKeys(){
  const p=parseInt(pInput.value),q=parseInt(qInput.value),e=parseInt(eInput.value);
  const phi=(p-1)*(q-1);const d=modInverse(e,phi);N=p*q;D=d;
  keyInfo.textContent=`n = ${N}, φ(n) = ${phi}, d = ${d}`;
}
function encrypt(){
  const text=plaintext.value.replace(/[^A-Za-z]/g,'');
  const e=parseInt(eInput.value);
  const cipher=text.split('').map(ch=>modPow(letterToNum(ch),e,N));
  cipherOut.textContent=cipher.join(' ');
}
function decrypt(){
  if(!D){recoverOut.textContent="Generate keys first!";return;}
  const nums=cipherOut.textContent.trim().split(/\s+/).map(Number);
  const plain=nums.map(c=>numToLetter(modPow(c,D,N))).join('');
  recoverOut.textContent=plain;plotFreq(plain);
}
const englishFreq={a:.08167,b:.01492,c:.02782,d:.04253,e:.12702,f:.02228,g:.02015,h:.06094,i:.06966,j:.00153,k:.00772,l:.04025,m:.02406,n:.06749,o:.07507,p:.01929,q:.00095,r:.05987,s:.06327,t:.09056,u:.02758,v:.00978,w:.02360,x:.00150,y:.01974,z:.00074};
function factorSmall(n){for(let i=2;i*i<=n;i++)if(n%i===0)return[i,n/i];return[n];}
function chiSquared(text){
  const counts={};let total=0;
  for(const ch of text.toLowerCase()){if(ch>='a'&&ch<='z'){counts[ch]=(counts[ch]||0)+1;total++;}}
  let s=0;for(const c in englishFreq){const obs=(counts[c]||0)/total;const exp=englishFreq[c];s+=Math.pow(obs-exp,2)/exp;}
  return s;
}
function attack(){
  const e=parseInt(eInput.value);const n=N;
  const [p,q]=factorSmall(n);const phi=(p-1)*(q-1);const d=modInverse(e,phi);
  const nums=cipherOut.textContent.trim().split(/\s+/).map(Number);
  const plain=nums.map(c=>numToLetter(modPow(c,d,n))).join('');
  const score=chiSquared(plain);
  recoverOut.textContent=`[Attack Result]\np=${p}, q=${q}, d=${d}\nPlaintext: ${plain}\nChi² score: ${score.toFixed(4)}`;
  plotFreq(plain);
}
function plotFreq(text){
  const freq={};let total=0;
  for(const ch of text.toLowerCase()){if(ch>='a'&&ch<='z'){freq[ch]=(freq[ch]||0)+1;total++;}}
  const letters=Object.keys(englishFreq);
  const english=letters.map(l=>englishFreq[l]*100);
  const observed=letters.map(l=>((freq[l]||0)/total)*100);
  const ctx=document.getElementById('freqPlot').getContext('2d');
  if(window.freqChart)window.freqChart.destroy();
  window.freqChart=new Chart(ctx,{
    type:'bar',
    data:{labels:letters,
      datasets:[
        {label:'English %',data:english,backgroundColor:'rgba(54,162,235,0.5)'},
        {label:'Decrypted %',data:observed,backgroundColor:'rgba(255,99,132,0.5)'}
      ]},
    options:{responsive:false,scales:{y:{beginAtZero:true,title:{display:true,text:'Frequency (%)'}}}}
  });
}
</script>