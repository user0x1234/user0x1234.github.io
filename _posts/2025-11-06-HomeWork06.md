---
layout: post
title: "HomeWork 6"
date: 2025-11-06
markdown: kramdown
---

Analytical Task
Derive the simplest proofs for the recurrence relationships of the arithmetic mean and variance. Implement and test the corresponding online algorithms, which update statistics incrementally as new data becomes available. Traditional "batch" algorithms should not be used, as they are computationally less efficient, more memory-intensive, and prone to numerical instability (e.g., error propagation, catastrophic cancellation, and overflow).

Optional Discussion
From a numerical analysis and computational perspective, discuss the advantages of online algorithms in terms of numerical stability, error propagation, catastrophic cancellation, and overflow management. You may also comment on their computational efficiency, robustness, and scalability, comparing them with traditional batch algorithms.

# ðŸ“Š Analytical Task: Online Algorithms for Mean and Variance (JavaScript)

---

## 1. Introduction

Traditional *batch algorithms* for computing statistical measures like the **mean** and **variance** require access to all data points at once.  
While conceptually simple, this approach becomes inefficient and unstable when working with large datasets or data streams.

**Online algorithms** (also called *incremental* or *streaming algorithms*) address these issues by updating the statistics dynamically â€” as each new observation arrives â€” without reprocessing or storing the entire dataset.

This document presents the mathematical derivations, JavaScript implementation, and numerical analysis of **Welfordâ€™s online algorithm** for computing the **arithmetic mean** and **variance** efficiently and stably.

---

## 2. Theoretical Background

### 2.1 Arithmetic Mean (Incremental Formula)

Let the mean after $\( n-1 \)$ observations be:

$$
\bar{x}_{n-1} = \frac{1}{n-1}\sum_{i=1}^{n-1} x_i
$$

When a new value $\( x_n \)$ is observed, the updated mean becomes:

$$
\bar{x}_n = \frac{1}{n}\sum_{i=1}^{n} x_i
$$

Substituting and simplifying:

$$
\bar{x}_n = \bar{x}_{n-1} + \frac{x_n - \bar{x}_{n-1}}{n}
$$

âœ… This recurrence relation updates the mean efficiently without revisiting past data.

---

### 2.2 Variance (Welfordâ€™s Recurrence Relation)

The population variance is defined as:

$$
\sigma_n^2 = \frac{1}{n}\sum_{i=1}^n (x_i - \bar{x}_n)^2
$$

To compute this incrementally, define:

$$
M_{2,n} = \sum_{i=1}^{n}(x_i - \bar{x}_n)^2
$$

When a new data point $\( x_n \)$ arrives:

$$
\begin{aligned}
\delta &= x_n - \bar{x}_{n-1} \\
\bar{x}_n &= \bar{x}_{n-1} + \frac{\delta}{n} \\
M_{2,n} &= M_{2,n-1} + \delta \cdot (x_n - \bar{x}_n)
\end{aligned}
$$

Finally, the variance is given by:

$$
\sigma^2 = \frac{M_{2,n}}{n}, \quad s^2 = \frac{M_{2,n}}{n-1}
$$

---

## 3. JavaScript Implementation

Below is a compact and efficient JavaScript implementation of **Welfordâ€™s online algorithm**.

  
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Online Mean and Variance (Welfordâ€™s Algorithm)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
  /*  body {
      font-family: "Helvetica", "Arial", sans-serif;
      background-color: #1e293b;
      color: #e2e8f0;
      margin: 0;
      padding: 2em;
      line-height: 1.6;
    }*/

    h1, h2, h3 {
      color: #38bdf8;
      text-align: center;
    }

    p, li {
      font-size: 1.1em;
      max-width: 900px;
      margin: auto;
      color: #cbd5e1;
    }

    .container {
      max-width: 900px;
      margin: 2em auto;
      background: #334155;
      border-radius: 12px;
      padding: 2em;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    .input-area {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 1.5em 0;
      gap: 1em;
    }

    input {
      padding: 0.5em;
      font-size: 1em;
      width: 150px;
      border-radius: 6px;
      border: none;
      outline: none;
    }

    button {
      padding: 0.6em 1.2em;
      font-size: 1em;
      background-color: #38bdf8;
      color: #0f172a;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s;
    }

    button:hover {
      background-color: #0ea5e9;
    }

    .stats {
      text-align: center;
      margin: 1em auto;
      background-color: #475569;
      border-radius: 8px;
      padding: 1em;
      width: 80%;
    }

    canvas {
      max-width: 100%;
      background: #0f172a;
      border-radius: 8px;
      padding: 1em;
    }

    footer {
      text-align: center;
      margin-top: 2em;
      font-size: 0.9em;
      color: #94a3b8;
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>ðŸ“Š Online Mean and Variance Estimation</h1>
    <h3>(Welfordâ€™s Algorithm with Chart.js Visualization)</h3>

    <p>
      Traditional batch algorithms for computing the <strong>mean</strong> and <strong>variance</strong> require storing all data points, which is inefficient for large datasets.
      <br><br>
      The <strong>Welfordâ€™s online algorithm</strong> efficiently updates these statistics as new data arrives â€” using constant memory and ensuring numerical stability.
    </p>

    <div class="input-area">
      <input type="number" id="dataInput" placeholder="Enter a number" />
      <button onclick="addData()">Add Data</button>
      <button onclick="resetData()">Reset</button>
    </div>

    <div class="stats">
      <h3>Current Statistics</h3>
      <p id="statsDisplay">No data yet.</p>
    </div>

    <canvas id="chart" height="120"></canvas>
  </div>

  <footer>
    <p>Developed for Statistical Analysis â€” Online Algorithm Demonstration using Welfordâ€™s Method</p>
  </footer>

  <script>
    // === Welfordâ€™s Online Algorithm ===
    class OnlineStats {
      constructor() {
        this.n = 0;
        this.mean = 0;
        this.M2 = 0;
        this.history = [];
      }

      update(x) {
        this.n++;
        const delta = x - this.mean;
        this.mean += delta / this.n;
        const delta2 = x - this.mean;
        this.M2 += delta * delta2;
        this.history.push(this.mean);
      }

      get varianceSample() {
        return this.n > 1 ? this.M2 / (this.n - 1) : 0;
      }

      get stdDev() {
        return Math.sqrt(this.varianceSample);
      }

      reset() {
        this.n = 0;
        this.mean = 0;
        this.M2 = 0;
        this.history = [];
      }
    }

    // === Initialize Stats + Chart ===
    const stats = new OnlineStats();

    const ctx = document.getElementById("chart").getContext("2d");
    const chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: [],
        datasets: [
          {
            label: "Running Mean",
            data: [],
            borderColor: "#38bdf8",
            backgroundColor: "rgba(56, 189, 248, 0.3)",
            borderWidth: 2,
            fill: true,
            tension: 0.25
          }
        ]
      },
      options: {
        scales: {
          x: {
            title: { display: true, text: "Observation Number", color: "#e2e8f0" },
            ticks: { color: "#e2e8f0" }
          },
          y: {
            title: { display: true, text: "Running Mean", color: "#e2e8f0" },
            ticks: { color: "#e2e8f0" }
          }
        },
        plugins: {
          legend: { labels: { color: "#e2e8f0" } }
        }
      }
    });

    // === Functions to Handle Data Input ===
    function addData() {
      const value = parseFloat(document.getElementById("dataInput").value);
      if (isNaN(value)) return alert("Please enter a valid number.");
      stats.update(value);

      chart.data.labels.push(stats.n);
      chart.data.datasets[0].data.push(stats.mean);
      chart.update();

      document.getElementById("statsDisplay").innerHTML = `
        Count (n): <strong>${stats.n}</strong><br>
        Mean (Î¼): <strong>${stats.mean.toFixed(3)}</strong><br>
        Variance (sÂ²): <strong>${stats.varianceSample.toFixed(3)}</strong><br>
        Std. Deviation (Ïƒ): <strong>${stats.stdDev.toFixed(3)}</strong>
      `;

      document.getElementById("dataInput").value = "";
    }

    function resetData() {
      stats.reset();
      chart.data.labels = [];
      chart.data.datasets[0].data = [];
      chart.update();
      document.getElementById("statsDisplay").innerHTML = "No data yet.";
    }
  </script>
</body>
</html>
