---
layout: post
title: "HomeWork 3"
date: 2025-10-23
markdown: kramdown
---


# üîê RSA Letter Encryption, Decryption & Frequency Attack (Fixed Version)

**RSA** is one of the most widely used public-key cryptographic algorithms and represents a cornerstone of modern cryptography.  
Unlike classical substitution ciphers, RSA is based on **number theory** and derives its security from the difficulty of factoring large integers.

This project presents a **fixed and simplified RSA implementation applied at the letter level**, designed for educational purposes. It demonstrates not only how RSA encryption and decryption work, but also how **improper usage** can lead to vulnerabilities such as **frequency attacks**.

---

## RSA Key Generation

RSA key generation follows these mathematical steps:

1. Choose two large prime numbers  
   $\(\, p, q \in \mathbb{P} \,\)$

2. Compute the modulus  
   $\(\, n = p \times q \,\)$

3. Compute Euler‚Äôs totient function  
   $\(\, \varphi(n) = (p - 1)(q - 1) \,\)$

4. Choose the public exponent  
   $\(\, 1 < e < \varphi(n) \;\land\; \gcd(e, \varphi(n)) = 1 \,\)$

5. Compute the private exponent  
   $\(\, d \equiv e^{-1} \pmod{\varphi(n)} \,\)$

---

## RSA Encryption and Decryption

Each plaintext letter is mapped to a numeric value:

$\(\, A \rightarrow 0,\; B \rightarrow 1,\; \dots,\; Z \rightarrow 25 \,\)$

### Encryption Formula

For each plaintext value $\(\, M \,\)$:

$\(\, C = M^{e} \bmod n \,\)$

Where:
- $\(\, M \,\)$ is the plaintext numeric value  
- $\(\, e \,\)$ is the public exponent  
- $\(\, n \,\)$ is the modulus  
- $\(\, C \,\)$ is the ciphertext  

---

### Decryption Formula

For each ciphertext value $\(\, C \,\)$:

$\(\, M = C^{d} \bmod n \,\)$

Where:
- $\(\, d \,\)$ is the private exponent  

---

## Fixed Letter-by-Letter RSA

In this **fixed version** of RSA:

- the same key pair $\(\, (e, n) \,\)$ and $\(\, (d, n) \,\)$ is always reused  
- each letter is encrypted independently  
- no padding or randomization is applied  

This makes the encryption **deterministic**:

$\(\, M_1 = M_2 \;\Rightarrow\; C_1 = C_2 \,\)$

---

## Security Weakness: Frequency Attack

Because encryption is deterministic, the statistical distribution of letters is preserved:

$\(\, \text{freq}(M) \approx \text{freq}(C) \,\)$

An attacker can exploit this by:

1. Computing ciphertext frequencies  
   $\(\, \text{freq}(C_i) = \dfrac{\text{count}(C_i)}{N} \,\)$

2. Comparing them with known language frequencies  
   $\(\, \text{freq}(E) > \text{freq}(T) > \text{freq}(A) > \dots \,\)$

3. Mapping the most frequent ciphertext values to the most probable plaintext letters

This results in a successful **frequency-based cryptanalysis**, even though RSA itself remains mathematically secure.

---

## Why Padding Is Required in Real RSA

Modern RSA implementations use padding schemes that introduce randomness:

$\(\, C = (M \,\|\, R)^{e} \bmod n \,\)$

Where:
- $\(\, R \,\)$ is random padding data  
- $\(\, \| \,\)$ denotes concatenation  

Padding ensures:

$\(\, M_1 = M_2 \;\Rightarrow\; C_1 \neq C_2 \,\)$

Examples of secure padding schemes include:
- **RSA-OAEP**
- **PKCS#1 v1.5** (legacy)

---

## Project Goal

The goal of **RSA Letter Encryption, Decryption & Frequency Attack (Fixed Version)** is to:

- explain RSA key generation using formal mathematical notation  
- implement RSA encryption and decryption at the letter level  
- demonstrate how deterministic encryption leaks information  
- show how frequency analysis can break naive RSA implementations  
- highlight the necessity of padding and randomness in cryptographic systems  

This project connects **classical cryptanalysis techniques** with **modern public-key cryptography**, providing a clear and rigorous understanding of both strengths and limitations.


---

## üßÆ Step 1: Choose RSA Parameters

Enter small primes and a public exponent, then click **Generate Keys**.

<input id="p" type="number" value="17" style="width:70px;"> √ó 
<input id="q" type="number" value="19" style="width:70px;">  
Public exponent **e**: <input id="e" type="number" value="5" style="width:70px;">  
<button onclick="generateKeys()">Generate Keys</button>

<div id="keyInfo" style="margin-top:10px;font-family:monospace;"></div>

---

## ‚úâÔ∏è Step 2: Encrypt a Message

<input id="plaintext" value="HELLOWORLD" style="width:100%;padding:8px;">  
<button onclick="encrypt()">Encrypt</button>

**Ciphertext (space-separated integers):**
<pre id="cipherOut" style="background:#f5f5f5;padding:6px;"></pre>

---

## üîì Step 3: Decrypt or Attack

<button onclick="decrypt()">Decrypt (using private key)</button>
<button onclick="attack()">Attack (factor n & analyze frequency)</button>

**Recovered text:**
<pre id="recoverOut" style="background:#f5f5f5;padding:6px;"></pre>

---

## üìä Step 4: Frequency Distribution Plot

The bar chart compares **English letter frequencies** with the **decrypted text** to check if it‚Äôs likely correct.

<canvas id="freqPlot" width="700" height="350"></canvas>

---

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// ---- Basic math helpers ----
function egcd(a,b){if(b===0)return{g:a,x:1,y:0};const r=egcd(b,a%b);return{g:r.g,x:r.y,y:r.x-Math.floor(a/b)*r.y};}
function modInverse(a,m){const r=egcd(a,m);if(r.g!==1)return null;return (r.x%m+m)%m;}
function modPow(b,e,m){let r=1n,base=BigInt(b)%BigInt(m);e=BigInt(e);m=BigInt(m);
  while(e>0n){if(e&1n)r=(r*base)%m;base=(base*base)%m;e>>=1n;}return Number(r);}
function letterToNum(c){const n=c.toUpperCase().charCodeAt(0)-65;return(n>=0&&n<26)?n:null;}
function numToLetter(n){return String.fromCharCode(65+(n%26));}

// ---- RSA Key variables ----
let N = null;
let D = null;

// ---- Generate Keys ----
function generateKeys(){
  const p = parseInt(document.getElementById('p').value);
  const q = parseInt(document.getElementById('q').value);
  const e = parseInt(document.getElementById('e').value);
  const phi = (p - 1) * (q - 1);
  const d = modInverse(e, phi);
  N = p * q;
  D = d;
  document.getElementById('keyInfo').textContent = `n = ${N}, œÜ(n) = ${phi}, d = ${d}`;
}

// ---- Encrypt ----
function encrypt(){
  const text = document.getElementById('plaintext').value.replace(/[^A-Za-z]/g,'');
  const e = parseInt(document.getElementById('e').value);
  if (!N) return alert("Generate keys first!");
  const cipher = text.split('').map(ch => modPow(letterToNum(ch), e, N));
  document.getElementById('cipherOut').textContent = cipher.join(' ');
}

// ---- Decrypt ----
function decrypt(){
  if (!D || !N) return alert("Generate keys first!");
  const nums = document.getElementById('cipherOut').textContent.trim().split(/\s+/).map(Number);
  const plain = nums.map(c => numToLetter(modPow(c, D, N))).join('');
  document.getElementById('recoverOut').textContent = plain;
  plotFreq(plain);
}

// ---- Frequency Analysis Attack ----
const englishFreq = {a:.08167,b:.01492,c:.02782,d:.04253,e:.12702,f:.02228,g:.02015,h:.06094,i:.06966,j:.00153,k:.00772,l:.04025,m:.02406,n:.06749,o:.07507,p:.01929,q:.00095,r:.05987,s:.06327,t:.09056,u:.02758,v:.00978,w:.02360,x:.00150,y:.01974,z:.00074};

function factorSmall(n){
  for(let i=2;i*i<=n;i++) if(n%i===0) return [i,n/i];
  return [n];
}

function chiSquared(text){
  const counts={};let total=0;
  for(const ch of text.toLowerCase()){if(ch>='a'&&ch<='z'){counts[ch]=(counts[ch]||0)+1;total++;}}
  let s=0;for(const c in englishFreq){const obs=(counts[c]||0)/total;const exp=englishFreq[c];s+=Math.pow(obs-exp,2)/exp;}
  return s;
}

function attack(){
  const e = parseInt(document.getElementById('e').value);
  const n = N;
  const [p,q] = factorSmall(n);
  const phi = (p-1)*(q-1);
  const d = modInverse(e,phi);
  const nums = document.getElementById('cipherOut').textContent.trim().split(/\s+/).map(Number);
  const plain = nums.map(c => numToLetter(modPow(c, d, n))).join('');
  const score = chiSquared(plain);
  document.getElementById('recoverOut').textContent = `[Attack Result]\np=${p}, q=${q}, d=${d}\nPlaintext: ${plain}\nChi¬≤ score: ${score.toFixed(4)}`;
  plotFreq(plain);
}

// ---- Plot English vs Decrypted Frequencies ----
function plotFreq(text){
  const freq={};let total=0;
  for(const ch of text.toLowerCase()){if(ch>='a'&&ch<='z'){freq[ch]=(freq[ch]||0)+1;total++;}}
  const letters=Object.keys(englishFreq);
  const english=letters.map(l=>englishFreq[l]*100);
  const observed=letters.map(l=>((freq[l]||0)/total)*100);
  const ctx=document.getElementById('freqPlot').getContext('2d');
  if(window.freqChart)window.freqChart.destroy();
  window.freqChart=new Chart(ctx,{
    type:'bar',
    data:{labels:letters,
      datasets:[
        {label:'English %',data:english,backgroundColor:'rgba(54,162,235,0.5)'},
        {label:'Decrypted %',data:observed,backgroundColor:'rgba(255,99,132,0.5)'}
      ]},
    options:{responsive:false,scales:{y:{beginAtZero:true,title:{display:true,text:'Frequency (%)'}}}}
  });
}
</script>
