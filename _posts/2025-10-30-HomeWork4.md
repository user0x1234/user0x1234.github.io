---
layout: post
title: "HomeWork 4"
date: 2025-10-30
markdown: kramdown
---

## Research Topics: Theory (T)

# ðŸŽ² Law of Large Numbers (LLN) Simulation

## ðŸ§­ Introduction

The **Law of Large Numbers (LLN)** is one of the cornerstones of probability theory.  
It describes how the average result of repeated independent experiments tends to stabilize around the expected value as the number of trials increases.

In plain language:  
> When we repeat a random experiment many times, the **observed frequency** of an event gets closer and closer to its **true probability**.

Formally, for independent and identically distributed (i.i.d.) random variables  
$\( X_1, X_2, \dots, X_n \)$ with mean $\( E[X_i] = \mu \)$, we have:

$$
\lim_{n \to \infty} \frac{1}{n} \sum_{i=1}^{n} X_i = \mu \quad \text{(with probability 1)}.
$$

---

## ðŸŽ¯ Purpose of This Simulation

In this interactive visualization, we simulate **Bernoulli trials** â€” simple random experiments with only two outcomes:
- **Success** with probability $\( p \)$
- **Failure** with probability $\( 1 - p \)$

For each trial sequence, we compute the **relative frequency of success** after \( n \) trials:

$$
f_n = \frac{\text{Number of successes after } n \text{ trials}}{n}.
$$

Multiple independent trajectories \( f_n^{(1)}, f_n^{(2)}, \dots, f_n^{(m)} \) are plotted to show how each path fluctuates at first but then converges toward the true probability \( p \) as \( n \) increases.

On the right, a **histogram** displays the distribution of final frequencies \( f_N \) after \( N \) trials for all trajectories.  
As \( N \) becomes large, this distribution becomes sharply concentrated near \( p \).

---

## ðŸ“‰ Theoretical Note: Variance Shrinking

For a Bernoulli random variable with success probability \( p \):

\[
\text{Var}(X_i) = p(1 - p).
\]

The variance of the sample mean (or relative frequency) after \( n \) trials is:

\[
\text{Var}(f_n) = \frac{p(1 - p)}{n}.
\]

This formula explains why the histogram of \( f_N \) narrows as \( n \) increases â€”  
the more data we collect, the smaller the variance becomes, and the more concentrated the results are around the true probability \( p \).

---

## ðŸ§ª Experiment Setup

- **m** â†’ number of independent trajectories (simulated experiments)  
- **N** â†’ number of trials per trajectory  
- **p** â†’ true probability of success in each trial  
- **f(n)** â†’ relative frequency of success after `n` trials  

By increasing `N`, youâ€™ll observe that:
- Individual trajectories fluctuate less over time.
- The histogram on the right compresses around \( p \).
- The average of all trajectories aligns closely with the true probability.

Together, these illustrate the **Law of Large Numbers** in action.

# ðŸ“ˆ Simulating the Law of Large Numbers (LLN)

**Goal:** simulate `m` independent trajectories of `n` Bernoulli trials with success probability `p`.  
Plot each trajectory \( f_n = S_n/n \) (running relative frequency) and, on the right, show a histogram of the final values \( f_N \). As `N` becomes large the histogram concentrates near `p`, illustrating the LLN.

---

**Controls:** choose number of trajectories `m`, number of trials `N`, and success probability `p`. Click **Run simulation**.

<div style="display:flex;gap:16px;align-items:flex-start;">
  <div style="flex:1; min-width: 420px;">
    <label>M (trajectories) <input id="mInput" type="number" value="50" min="1" max="500" style="width:90px"></label>
    <label>N (trials) <input id="nInput" type="number" value="500" min="10" max="50000" step="10" style="width:90px"></label>
    <label>p (success probability) <input id="pInput" type="number" value="0.3" min="0" max="1" step="0.01" style="width:90px"></label>
    <label>Bins (histogram) <input id="binsInput" type="number" value="25" min="5" max="100" style="width:90px"></label>
    <button onclick="runSim()" style="display:block;margin-top:8px;padding:8px 12px;">Run simulation</button>

    <div style="margin-top:12px; font-size:0.95rem; color:#333;">
      <strong>Notes:</strong> For performance, avoid extremely large `m` and very large `N` simultaneously. Use defaults (m=50, N=500) to see the effect quickly.
    </div>

    <canvas id="trajChart" width="820" height="420" style="margin-top:12px;border:1px solid #eee;"></canvas>
  </div>

  <div style="width:300px;">
    <div style="text-align:center; font-weight:600; margin-bottom:6px;">Histogram of final f<sub>N</sub></div>
    <canvas id="histChart" width="300" height="420" style="border:1px solid #eee;"></canvas>
    <div id="histInfo" style="font-size:0.9rem; margin-top:10px;"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
/* ---------- Utility: simulate m trajectories ---------- */
function simulateTrajectories(m, N, p) {
  // returns array of length m, each is array f[1..N] of running relative frequencies
  const trajs = new Array(m);
  for (let i = 0; i < m; i++) {
    const f = new Array(N);
    let successes = 0;
    for (let n = 1; n <= N; n++) {
      if (Math.random() < p) successes++;
      f[n-1] = successes / n;
    }
    trajs[i] = f;
  }
  return trajs;
}

/* ---------- Make histogram bins ---------- */
function histogram(data, bins) {
  const counts = new Array(bins).fill(0);
  const min = 0, max = 1;
  const width = (max - min) / bins;
  for (const v of data) {
    // clamp edge-case v===1 into last bin
    let idx = Math.floor((v - min) / width);
    if (idx < 0) idx = 0;
    if (idx >= bins) idx = bins - 1;
    counts[idx]++;
  }
  const edges = [];
  for (let i = 0; i < bins; i++) edges.push(min + (i + 0.5) * width);
  return {counts, edges, width};
}

/* ---------- Chart objects ---------- */
let trajChart = null;
let histChart = null;

/* ---------- Run simulation and plot ---------- */
function runSim() {
  const m = Math.max(1, Math.min(500, parseInt(document.getElementById('mInput').value) || 50));
  const N = Math.max(10, Math.min(50000, parseInt(document.getElementById('nInput').value) || 500));
  const p = Math.min(1, Math.max(0, parseFloat(document.getElementById('pInput').value) || 0.3));
  const bins = Math.max(5, Math.min(200, parseInt(document.getElementById('binsInput').value) || 25));

  // simulate
  const trajs = simulateTrajectories(m, N, p);
  const finalFs = trajs.map(t => t[N-1]);

  // prepare datasets for trajectories (sampled lines to avoid over-plotting)
  // We'll plot all trajectories but subsample points for large N (display every step up to 200 pts)
  const maxPoints = 400;
  const step = Math.max(1, Math.floor(N / maxPoints));
  const labels = Array.from({length: Math.ceil(N/step)}, (_,i) => (i*step + 1).toString());

  const datasets = trajs.map((t, idx) => {
    // compute sampled values
    const data = [];
    for (let i = 0; i < N; i += step) data.push({x: i+1, y: t[i]});
    // semi-transparent gray lines, slightly colored
    const opacity = 0.18;
    const hue = Math.floor((idx / Math.max(1,m)) * 240); // blueish spread
    return {
      label: 'traj'+idx,
      data,
      borderColor: `hsla(${hue},70%, 35%, ${opacity})`,
      backgroundColor: `hsla(${hue},70%, 35%, ${opacity})`,
      tension: 0.15,
      fill: false,
      pointRadius: 0,
      borderWidth: 1
    };
  });

  // add a bold average-of-trajectories line (empirical mean across trajectories)
  const meanData = [];
  for (let i = 0; i < N; i += step) {
    let s = 0;
    for (let j = 0; j < m; j++) s += trajs[j][i];
    meanData.push({x: i+1, y: s / m});
  }
  datasets.push({
    label: 'Empirical mean f_n (avg over trajectories)',
    data: meanData,
    borderColor: 'rgba(220,20,60,1)',
    backgroundColor: 'rgba(220,20,60,1)',
    borderWidth: 2.2,
    pointRadius: 0,
    tension: 0.25
  });

  // horizontal line at p (theoretical)
  const pLine = {
    label: 'True p',
    data: [{x:1, y:p}, {x:N, y:p}],
    borderColor: 'rgba(20,130,20,0.95)',
    borderWidth: 2,
    pointRadius: 0,
    fill: false,
    type: 'line'
  };
  datasets.push(pLine);

  // create/replace trajectory chart
  const ctx = document.getElementById('trajChart').getContext('2d');
  if (trajChart) trajChart.destroy();
  trajChart = new Chart(ctx, {
    type: 'line',
    data: {datasets},
    options: {
      animation: false,
      plugins: {
        legend: { display: false },
        tooltip: { mode: 'nearest', intersect: false }
      },
      scales: {
        x: {
          type: 'linear',
          title: {display:true, text: 'n (number of trials)'},
          min: 1,
          max: N
        },
        y: {
          title: {display:true, text: 'f_n = S_n / n (relative frequency)'},
          min: 0,
          max: 1
        }
      },
      elements: { line: { spanGaps: true } }
    }
  });

  // histogram of final f_N
  const hist = histogram(finalFs, bins);
  const histData = hist.counts;
  const histLabels = hist.edges.map(v => v.toFixed(3));
  const hctx = document.getElementById('histChart').getContext('2d');
  if (histChart) histChart.destroy();
  histChart = new Chart(hctx, {
    type: 'bar',
    data: {
      labels: histLabels,
      datasets: [{
        label: `Counts of f_N (N=${N})`,
        data: histData,
        backgroundColor: 'rgba(54,162,235,0.8)',
        borderColor: 'rgba(54,162,235,1)',
        borderWidth: 1
      }]
    },
    options: {
      indexAxis: 'x',
      animation: false,
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { title: (ctx) => `bin center: ${ctx[0].label}` } }
      },
      scales: {
        x: {
          title: { display: true, text: 'final f_N (bin centers)' },
          ticks: { maxRotation: 90, minRotation: 45 }
        },
        y: {
          title: { display: true, text: 'Count (out of ' + m + ')' }
        }
      }
    }
  });

  // show histogram summary
  const meanFinal = (finalFs.reduce((a,b)=>a+b,0)/finalFs.length);
  const sdFinal = Math.sqrt(finalFs.reduce((a,b)=>a+(b-meanFinal)**2,0)/finalFs.length);
  document.getElementById('histInfo').innerHTML =
    `<div>m = <strong>${m}</strong>, N = <strong>${N}</strong>, p = <strong>${p}</strong></div>` +
    `<div style="margin-top:6px">Mean of final f<sub>N</sub>: <strong>${meanFinal.toFixed(4)}</strong></div>` +
    `<div>Std dev: <strong>${sdFinal.toFixed(4)}</strong></div>` +
    `<div style="margin-top:6px; font-size:0.9em; color:#555">As N increases the histogram concentrates near p; the empirical mean â‰ˆ p (LLN).</div>`;
}

// run initial simulation
runSim();
</script>
