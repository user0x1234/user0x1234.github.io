---
layout: post
title: "HomeWork 2"
date: 2025-10-16
markdown: kramdown
---

# Building and Analyzing a Small Dataset Using a DBMS

## 1. Objective

The goal of this assignment is to:
- build a small dataset using a **Database Management System (DBMS)**,
- store structured data in a relational table,
- compute **univariate distributions** for selected variables, with dimensionality $\( k \leq 3 \)$.

This exercise introduces the connection between databases and statistical data analysis.

---

## 2. Dataset Design

We consider a simple dataset representing **server security events**, stored in a relational table.

### Table: `server_logs`

| Attribute | Description |
|----------|------------|
| `id` | Event identifier |
| `server_id` | Server identifier |
| `attack_type` | Type of attack |
| `success` | Whether the attack was successful (0/1) |

---

## 3. Creating the Dataset (SQL)

```sql
CREATE TABLE server_logs (
    id INTEGER PRIMARY KEY,
    server_id INTEGER,
    attack_type TEXT,
    success INTEGER
);


INSERT INTO server_logs VALUES
(1, 1, 'DDoS', 0),
(2, 1, 'Phishing', 1),
(3, 2, 'DDoS', 0),
(4, 2, 'Malware', 1),
(5, 3, 'DDoS', 0),
(6, 3, 'Phishing', 0),
(7, 1, 'Malware', 1),
(8, 2, 'Phishing', 0);

```

## 4. Univariate Distributions (k ‚â§ 3)
### 4.1 Distribution of Attack Types (k = 1)

This query computes the absolute frequency distribution of attack types.
```sql
SELECT attack_type, COUNT(*) AS frequency
FROM server_logs
GROUP BY attack_type;
```



## 4.2 Distribution of Successful Attacks (k = 1)
This produces a binary distribution (success vs failure).

```sql
SELECT success, COUNT(*) AS frequency
FROM server_logs
GROUP BY success;
```

## 4.3 Bivariate Distribution of Attack Type and Outcome (k = 2)

For **k = 2**, we analyze a **bivariate (joint) distribution**, which describes how two variables behave together.
In this case, we study the relationship between the **type of attack** and its **outcome** (successful or not).

### SQL Query

The following query computes the joint frequency distribution of `attack_type` and `success`:

```sql
SELECT attack_type, success, COUNT(*) AS frequency
FROM server_logs
GROUP BY attack_type, success
ORDER BY attack_type, success;
```

### Interpretation
- Each row represents a pair **(attack_type, success)**
- success = 1 indicates a successful attack, success = 0 a failed one
- frequency shows how often each combination occurs

This distribution allows us to:
- Compare the effectiveness of different attack types
- Identify attacks with higher success rates
- Support early risk assessment and threat prioritization

# Caesar Cipher Analysis and Decoding via Frequency Distribution (JavaScript)

This example demonstrates how to:
1. Compute the letter frequency distribution of a given text  
2. Encrypt it using a Caesar cipher  
3. Automatically decode it *without knowing the shift*, using English language frequency statistics

---

# üîê Caesar Cipher with Auto Decode (Frequency Analysis)

The **Caesar Cipher** is one of the oldest and simplest encryption techniques, historically attributed to **Julius Caesar**, who used it to protect military communications.  
It is a **substitution cipher** in which each letter of the plaintext is replaced by another letter shifted by a fixed number of positions in the alphabet.

---

## How the Caesar Cipher Works
The cipher is based on a fixed **shift value**:
- a number `k` (the key) is chosen
- each letter is shifted forward by `k` positions
- the alphabet is circular (after `Z`, it starts again from `A`)


While extremely simple, the Caesar Cipher is important from an educational perspective because it introduces fundamental concepts of classical cryptography.

---

## Security Limitations
The Caesar Cipher is **not secure** by modern standards due to two main weaknesses:
1. The key space is very small (only 25 possible shifts)
2. It preserves the **statistical distribution of letters** from the original language

These weaknesses make it vulnerable to cryptanalysis techniques, especially **Frequency Analysis**.

---

## Auto Decode Using Frequency Analysis
**Frequency Analysis** exploits the fact that, in any natural language, some letters appear more frequently than others.  


The **Auto Decode** process works as follows:
1. calculate the frequency of each letter in the ciphertext
2. compare these frequencies with typical language distributions
3. determine the most likely shift value
4. automatically decrypt the message without knowing the key

This approach allows the Caesar Cipher to be **broken automatically**, even when the shift is unknown.

---

## Project Goal
The goal of **Caesar Cipher with Auto Decode (Frequency Analysis)** is to:
- implement Caesar Cipher encryption and decryption
- analyze letter frequencies in the ciphertext
- automatically detect the correct shift
- demonstrate why classical ciphers are insecure against statistical attacks

This project serves as an excellent introduction to:
- classical cryptography
- basic cryptanalysis techniques
- the importance of modern encryption algorithms

---

### ‚úçÔ∏è Input

<input id="textInput" type="text" placeholder="Enter your text here" style="width: 100%; padding: 8px; margin-bottom: 10px;">
<label for="shiftInput">Shift:</label>
<input id="shiftInput" type="number" value="10" min="0" max="25" style="width: 60px; margin-left: 5px;">
<button onclick="runCipher()" style="margin-left: 10px; padding: 5px 10px;">Run</button>

---

### üî¢ Output

**Encrypted:**  
<pre id="encryptedText"></pre>

**Auto-Decoded:**  
<pre id="decodedText"></pre>

**Detected Shift:**  
<pre id="detectedShift"></pre>

---

<script>
// Frequency of letters in English language (approximate)
const englishFreq = {
  a: 0.08167, b: 0.01492, c: 0.02782, d: 0.04253, e: 0.12702,
  f: 0.02228, g: 0.02015, h: 0.06094, i: 0.06966, j: 0.00153,
  k: 0.00772, l: 0.04025, m: 0.02406, n: 0.06749, o: 0.07507,
  p: 0.01929, q: 0.00095, r: 0.05987, s: 0.06327, t: 0.09056,
  u: 0.02758, v: 0.00978, w: 0.02360, x: 0.00150, y: 0.01974,
  z: 0.00074
};

// Compute frequency of letters in a given text
function letterFrequency(text) {
  const freq = {};
  let total = 0;
  for (const char of text.toLowerCase()) {
    if (/[a-z]/.test(char)) {
      freq[char] = (freq[char] || 0) + 1;
      total++;
    }
  }
  for (const c in freq) freq[c] /= total;
  return freq;
}

// Apply Caesar cipher with given shift
function caesarEncrypt(text, shift) {
  return text.replace(/[a-z]/gi, c => {
    const base = c === c.toUpperCase() ? 65 : 97;
    return String.fromCharCode((c.charCodeAt(0) - base + shift) % 26 + base);
  });
}

// Caesar decrypt with given shift
function caesarDecrypt(text, shift) {
  return caesarEncrypt(text, 26 - shift);
}

// Score text frequency against English using Chi-squared test
function chiSquaredScore(text) {
  const freq = letterFrequency(text);
  let score = 0;
  for (const letter in englishFreq) {
    const observed = freq[letter] || 0;
    const expected = englishFreq[letter];
    score += Math.pow(observed - expected, 2) / expected;
  }
  return score;
}

// Auto-decode Caesar cipher using frequency analysis
function caesarAutoDecode(ciphertext) {
  let bestShift = 0;
  let lowestScore = Infinity;
  for (let shift = 0; shift < 26; shift++) {
    const decrypted = caesarDecrypt(ciphertext, shift);
    const score = chiSquaredScore(decrypted);
    if (score < lowestScore) {
      lowestScore = score;
      bestShift = shift;
    }
  }
  return {
    shift: bestShift,
    plaintext: caesarDecrypt(ciphertext, bestShift)
  };
}

// Main UI logic
function runCipher() {
  const text = document.getElementById('textInput').value;
  const shift = parseInt(document.getElementById('shiftInput').value) || 0;
  const encrypted = caesarEncrypt(text, shift);
  const decoded = caesarAutoDecode(encrypted);

  document.getElementById('encryptedText').textContent = encrypted;
  document.getElementById('decodedText').textContent = decoded.plaintext;
  document.getElementById('detectedShift').textContent = decoded.shift;
}
</script>
