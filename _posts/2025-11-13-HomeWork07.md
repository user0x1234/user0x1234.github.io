---
layout: post
title: "HomeWork 7"
date: 2025-11-13
markdown: kramdown
---

# üß† Random Walk Simulation ‚Äî Server Security vs. Binomial Distribution


# Random Walk Simulation ‚Äî Server Security vs. Binomial Distribution

A **Random Walk** is a stochastic process that describes a path formed by a sequence of random steps.  
It is widely used in mathematics, physics, finance, and computer science to model systems whose behavior evolves under uncertainty.

In this project, a random walk is used as an **abstract model of server security**, where each step represents a security-related event that can either improve or weaken the system‚Äôs overall security state.

---

## Random Walk as a Security Model

The security level of a server can be represented as a one-dimensional position on a number line:

- a step to the **right** represents a positive security event  
  (e.g. successful patching, intrusion detection, system hardening)
- a step to the **left** represents a negative security event  
  (e.g. failed login attempts, vulnerabilities, partial compromises)

Each step is assumed to be **independent and random**, making the system suitable for probabilistic analysis.

---

## Connection to the Binomial Distribution

A random walk with a fixed number of steps can be modeled using the **binomial distribution**.

Let:
- $\(\, n \,\)$ be the number of security events
- $\(\, p \,\)$ be the probability of a positive security outcome
- $\(\, X \,\)$ be the number of positive events

Then:

$\(\, X \sim \text{Binomial}(n, p) \,\)$

The final security position of the server after $n$ steps is:

$\(\, S = 2X - n \,\)$

This relationship allows us to:
- predict expected security outcomes
- compute probabilities of critical security states
- compare simulation results with theoretical distributions

---

## Simulation vs. Theory

The project compares:
- **empirical results** from random walk simulations
- **analytical results** derived from the binomial distribution

By increasing the number of simulations, the empirical distribution converges toward the theoretical binomial model, illustrating fundamental principles such as:
- the **Law of Large Numbers**
- probabilistic convergence
- statistical predictability in complex systems

---

## Project Goal

The goal of **Random Walk Simulation ‚Äî Server Security vs. Binomial Distribution** is to:

- model server security evolution using a random walk
- connect discrete simulations with formal probability theory
- analyze risk and stability in security systems
- demonstrate how randomness and probability impact real-world security scenarios

This project provides an intuitive bridge between **stochastic processes**, **probability distributions**, and **cybersecurity modeling**.

---

## üìò Concept


This simulation explores how a **server‚Äôs weekly security outcomes** (secure or breached) can be modeled as a **random walk**, and how the **distribution of final scores** converges to a **binomial distribution**.

- We have **n weeks** and **m simulated servers**.  
- Each week:
  - The server stays **secure** with probability `q = 1 ‚àí p` ‚Üí adds **+1**.
  - The server is **breached** with probability `p` ‚Üí adds **‚àí1**.
- The **final cumulative score** after n weeks:
  
   $$
  S = (+1)k + (-1)(n-k) = 2k - n
  $$
  
  where `k` = number of secure weeks.  
  Since $\( k \sim Binomial(n, q) \)$, the score distribution corresponds directly to the binomial.

As we simulate more servers (`m ‚Üë`), the **empirical histogram** of scores converges to the **theoretical binomial**.  
As `n ‚Üë`, the binomial itself becomes increasingly **normal** (via the Central Limit Theorem).

---

## üíª Interactive Simulation (HTML + JS + Chart.js)

<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Random Walk ‚Äî Server Security Binomial Simulation</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  .controls input { margin:4px; }
  canvas { background:#081020; border-radius:8px; margin-top:8px; }
  .panel { background:#0b1222; padding:12px; border-radius:10px; margin-bottom:20px; }
  button { background:#61a5ff; border:none; color:#000; padding:6px 10px; border-radius:6px; font-weight:bold; cursor:pointer; }
  .stats span { margin-right:12px; display:inline-block; background:#182a44; padding:6px 10px; border-radius:8px; }
</style>
</head>
<body>
<h1>üîê Server Security ‚Äî Random Walk & Binomial Simulation</h1>
<p>
Each trajectory represents the server‚Äôs weekly cumulative security score (+1 if secure, ‚àí1 if breached).
The histogram compares empirical results (blue) vs. theoretical Binomial predictions (green).
</p>

<div class="panel">
  <div class="controls">
    <label>Weeks (n): <input id="nInput" type="number" min="1" value="50"/></label>
    <label>Trajectories (m): <input id="mInput" type="number" min="1" value="500"/></label>
    <label>Breach probability (p): <input id="pInput" type="number" min="0" max="1" step="0.01" value="0.3"/></label>
    <label>Plot max trajectories: <input id="capInput" type="number" value="150"/></label>
    <button id="run">Run</button>
    <button id="clear">Clear</button>
  </div>
</div>

<div class="panel">
  <h3>üß© Random Walk Trajectories</h3>
  <canvas id="trajChart" height="280"></canvas>
  <div class="stats">
    <span id="mean">Mean: ‚Äî</span>
    <span id="var">Variance: ‚Äî</span>
    <span id="dist">L1 distance: ‚Äî</span>
  </div>
</div>

<div class="panel">
  <h3>üìä Final Score Histogram (Empirical vs. Binomial)</h3>
  <canvas id="histChart" height="280"></canvas>
</div>

<script>
// === Utility Functions ===
function bernoulli(q){ return Math.random() < q ? 1 : -1; }
function binomPMF(n,q){
  const p=1-q, pmf=[Math.pow(p,n)];
  for(let k=1;k<=n;k++) pmf[k]=pmf[k-1]*(n-(k-1))/k*(q/p);
  return pmf;
}
function kToScore(k,n){ return 2*k-n; }
function l1(a,b){ return a.reduce((s,v,i)=>s+Math.abs(v-b[i]),0); }

// === Chart Initialization ===
const trajCtx = document.getElementById('trajChart');
const histCtx = document.getElementById('histChart');

let trajChart = new Chart(trajCtx, {
  type: 'line',
  data: { datasets: [] },
  options: {
    animation: false,
    plugins: { legend: { display: false } },
    scales: {
      x: { title: { display: true, text: 'Week' } },
      y: { title: { display: true, text: 'Cumulative Score' } }
    }
  }
});

let histChart = new Chart(histCtx, {
  type: 'bar',
  data: {
    labels: [],
    datasets: [
      { label: 'Empirical counts', backgroundColor: 'rgba(96,165,250,0.8)', data: [] },
      { label: 'Theoretical counts', type: 'line', borderColor: 'rgba(34,197,94,1)', fill: false, data: [] }
    ]
  },
  options: {
    animation: false,
    scales: {
      x: { title: { display: true, text: 'Final Score' } },
      y: { title: { display: true, text: 'Count' } }
    }
  }
});

// === Main Simulation Function ===
document.getElementById('run').onclick = () => {
  const n = parseInt(document.getElementById('nInput').value);
  const m = parseInt(document.getElementById('mInput').value);
  const p = parseFloat(document.getElementById('pInput').value);
  const q = 1 - p;
  const cap = parseInt(document.getElementById('capInput').value);

  const counts = new Array(n+1).fill(0);
  const plot = [];
  let sum = 0, sum2 = 0;

  for(let i=0; i<m; i++){
    let s=0, k=0, traj=[];
    for(let t=0; t<n; t++){
      const step = bernoulli(q);
      s += step;
      if(step===1) k++;
      traj.push({x:t+1, y:s});
    }
    counts[k]++;
    sum += s;
    sum2 += s*s;
    if(i < cap) plot.push(traj);
  }

  // Update trajectory plot
  trajChart.data.datasets = plot.map(tr => ({
    data: tr,
    borderColor: 'rgba(96,165,250,0.15)',
    pointRadius: 0
  }));

  const expected = [];
  for(let t=1; t<=n; t++) expected.push({x:t, y:t*(2*q-1)});
  trajChart.data.datasets.push({
    data: expected,
    borderColor: 'rgba(34,197,94,1)',
    borderWidth: 2
  });
  trajChart.update();

  // Update histogram
  const pmf = binomPMF(n,q);
  const theory = pmf.map(v => v*m);
  const scores = counts.map((_,k) => kToScore(k,n));
  histChart.data.labels = scores.map(String);
  histChart.data.datasets[0].data = counts;
  histChart.data.datasets[1].data = theory;
  histChart.update();

  // Stats display
  const mean = sum/m;
  const variance = sum2/m - mean*mean;
  const empirical = counts.map(v => v/m);
  document.getElementById('mean').textContent = `Mean: ${mean.toFixed(3)}`;
  document.getElementById('var').textContent = `Variance: ${variance.toFixed(3)}`;
  document.getElementById('dist').textContent = `L1 distance: ${l1(empirical, pmf).toExponential(3)}`;
};

// === Clear Button ===
document.getElementById('clear').onclick = () => {
  trajChart.data.datasets = [];
  trajChart.update();
  histChart.data.labels = [];
  histChart.data.datasets.forEach(d => d.data = []);
  histChart.update();
  ['mean','var','dist'].forEach(id => document.getElementById(id).textContent = `${id}: ‚Äî`);
};
</script>
</body>

