---
layout: post
title: "HomeWork 7"
date: 2025-11-06
markdown: kramdown
---

# üß† Random Walk Simulation ‚Äî Server Security vs. Binomial Distribution

This simulation explores how a **server‚Äôs weekly security outcomes** (secure or breached) can be modeled as a **random walk**, and how the **distribution of final scores** converges to a **binomial distribution**.

---

## üìò Concept

- We have **n weeks** and **m simulated servers**.  
- Each week:
  - The server stays **secure** with probability `q = 1 ‚àí p` ‚Üí adds **+1**.
  - The server is **breached** with probability `p` ‚Üí adds **‚àí1**.
- The **final cumulative score** after n weeks:
  
   $$
  S = (+1)k + (-1)(n-k) = 2k - n
  $$
  
  where `k` = number of secure weeks.  
  Since $\( k \sim Binomial(n, q) \)$, the score distribution corresponds directly to the binomial.

As we simulate more servers (`m ‚Üë`), the **empirical histogram** of scores converges to the **theoretical binomial**.  
As `n ‚Üë`, the binomial itself becomes increasingly **normal** (via the Central Limit Theorem).

---

## üíª Interactive Simulation (HTML + JS + Chart.js)

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Random-walk server security ‚Äî Empirical vs Binomial</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{
    --bg:#0f1724; --panel:#0b1220; --muted:#9fb0d7; --accent:#60a5fa; --good:#16a34a;
  }
  body { background:var(--bg); color:var(--muted); font-family:Inter,system-ui,Arial; margin:0; padding:18px; }
  .wrap { max-width:1100px; margin:0 auto; }
  h1{ color:var(--accent); margin:0 0 8px 0; }
  p.lead{ margin:6px 0 18px 0; color:#bfcfe8; }
  .controls { display:flex; gap:12px; flex-wrap:wrap; margin-bottom:14px; }
  .controls label{ font-size:0.9rem; color:var(--muted); }
  input[type=number], input[type=range], input[type=text] { padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:var(--muted); }
  button{ background:var(--accent); color:#041026; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:600; }
  button.secondary{ background:#182235; color:var(--muted); border:1px solid rgba(255,255,255,0.03); }
  .grid { display:grid; grid-template-columns: 1fr 380px; gap:18px; align-items:start; }
  .panel { background:linear-gradient(180deg,#07101a,#061021); padding:14px; border-radius:12px; box-shadow:0 6px 30px rgba(0,0,0,0.6);}
  .small { font-size:0.9rem; color:#9fb0d7; }
  canvas { background:#071428; border-radius:8px; }
  .statline { display:flex; gap:12px; flex-wrap:wrap; margin-top:8px; }
  .badge { background:rgba(255,255,255,0.03); padding:8px 10px; border-radius:8px; color:var(--muted); font-weight:600; }
  footer { margin-top:18px; color:#8fa6d2; font-size:0.9rem; }
  @media (max-width:980px){ .grid{ grid-template-columns:1fr; } }
</style>
</head>
<body>
<div class="wrap">
  <h1>Server Security Random Walks ‚Äî Empirical vs Binomial</h1>
  <p class="lead">Simulate <strong>m</strong> independent server trajectories of length <strong>n</strong> weeks.  
  Each week the server is <em>secure</em> with probability <strong>q = 1 ‚àí p</strong> (score +1), or <em>breached</em> with probability <strong>p</strong> (score ‚àí1).  
  Final total score after n weeks is equivalent to 2¬∑(number of secure weeks) ‚àí n, so the distribution of final scores maps directly to a <strong>Binomial(n, q)</strong> distribution.</p>

  <div class="controls">
    <label>Weeks n: <input id="nInput" type="number" min="1" max="2000" value="50" /></label>
    <label>Trajectories m: <input id="mInput" type="number" min="1" max="5000" value="500" /></label>
    <label>Breached prob. p: <input id="pInput" type="number" step="0.01" min="0" max="1" value="0.3" /></label>
    <label>Plot sample cap: <input id="capInput" type="number" min="1" max="1000" value="200" /> (max trajectories drawn)</label>

    <button id="runBtn">Run simulation</button>
    <button id="clearBtn" class="secondary">Clear</button>
  </div>

  <div class="grid">
    <div class="panel">
      <h3 style="margin-top:0;color:#cfe6ff">Trajectories (random walks)</h3>
      <canvas id="trajChart" height="260"></canvas>
      <div class="statline">
        <div class="badge" id="meanBadge">Empirical mean final score: ‚Äî</div>
        <div class="badge" id="varBadge">Empirical var final score: ‚Äî</div>
        <div class="badge" id="distBadge">L1 distance to theory: ‚Äî</div>
      </div>
      <p class="small" style="margin-top:10px;">
        Notes: trajectories show cumulative score (secure=+1, breach=‚àí1). Final possible scores range from <code>‚àín</code> to <code>+n</code> in steps of 2.
      </p>
    </div>

    <div class="panel">
      <h3 style="margin-top:0;color:#cfe6ff">Final Score Histogram</h3>
      <canvas id="histChart" height="260"></canvas>
      <p class="small" id="histInfo" style="margin-top:8px;"></p>
    </div>
  </div>

  <section class="panel" style="margin-top:14px;">
    <h3 style="margin-top:0;color:#cfe6ff">Explanation & Math</h3>
    <p class="small">
      If a trajectory has <strong>k</strong> secure weeks (each with probability <em>q = 1 ‚àí p</em>), then the **final score**
      \[
        S = (+1)\cdot k + (-1)\cdot (n-k) = 2k - n.
      \]
      Thus k = (S + n) / 2 and k ~ Binomial(n, q). The histogram bins are easily mapped to binomial probabilities; the theoretical count for score S is
      \[
        \text{theoryCount}(S) = m \cdot \binom{n}{k} q^{k} (1-q)^{n-k}.
      \]
    </p>
    <p class="small">
      As <strong>m ‚Üí ‚àû</strong>, the empirical frequency of final scores converges to the binomial distribution. As <strong>n</strong> grows, the binomial becomes increasingly concentrated (relative variance ‚àù 1/n), and via CLT it approximates a normal distribution around mean m¬∑(2q‚àí1).
    </p>
  </section>

  <footer>
    Tip: Increase <strong>m</strong> (trajectories) to see empirical histogram approach theory; increase <strong>n</strong> to see change in spread. Keep plotting cap modest to avoid visual clutter.
  </footer>
</div>

<script>
/* Helper functions */

// Random bernoulli: returns 1 for secure (with prob q), -1 for breach (with prob p)
function bernoulliStep(q) {
  return Math.random() < q ? 1 : -1;
}

// Compute binomial pmf array for k=0..n
function binomialPMF(n, q) {
  // Compute pmf with multiplicative approach to avoid huge factorials
  const pmf = new Array(n+1).fill(0);
  let c = 1; // C(n,0)
  pmf[0] = Math.pow(1-q, n);
  for (let k=1; k<=n; k++) {
    // recurrence: pmf[k] = pmf[k-1] * (n - (k - 1)) / k * (q / (1-q))
    pmf[k] = pmf[k-1] * (n - (k - 1)) / k * (q / (1 - q));
  }
  // numerical rounding may cause tiny negative; clamp
  for (let k=0;k<=n;k++) if (pmf[k] < 0) pmf[k] = 0;
  return pmf;
}

// Map k (number of secure weeks) to final score S = 2k - n
function kToScore(k, n) {
  return 2*k - n;
}

// Map score S to index in bins array: index = (S + n)/2
function scoreToIndex(S, n) {
  return (S + n) / 2;
}

// L1 distance between empirical pmf and theoretical pmf arrays
function l1Distance(a, b) {
  // a,b arrays same length
  let s=0;
  for (let i=0;i<a.length;i++) s += Math.abs((a[i]||0) - (b[i]||0));
  return s;
}

/* Chart initialization */

const trajCtx = document.getElementById('trajChart').getContext('2d');
const histCtx = document.getElementById('histChart').getContext('2d');

let trajChart = new Chart(trajCtx, {
  type: 'line',
  data: { datasets: [] },
  options: {
    animation:false,
    maintainAspectRatio:false,
    elements: { point: { radius: 0 } },
    plugins: { legend: { display:false } },
    scales: {
      x: { title:{display:true, text:'Week (n)'}, ticks:{color:'#bcd'} },
      y: { title:{display:true, text:'Cumulative score'}, ticks:{color:'#bcd'} }
    }
  }
});

let histChart = new Chart(histCtx, {
  type: 'bar',
  data: { labels: [], datasets: [
    { label: 'Empirical counts', data: [], backgroundColor: 'rgba(96,165,250,0.8)' },
    { label: 'Theoretical counts', data: [], type: 'line', borderColor: 'rgba(34,197,94,0.9)', backgroundColor:'rgba(34,197,94,0.2)', fill:false, tension:0.2, yAxisID: 'y' }
  ]},
  options: {
    animation:false,
    maintainAspectRatio:false,
    scales: {
      x: { title:{display:true, text:'Final score S (2k-n)'}, ticks:{color:'#bcd'} },
      y: { title:{display:true, text:'Counts (out of m)'}, ticks:{color:'#bcd'} }
    },
    plugins: { legend: { labels:{color:'#bcd'} } }
  }
});

/* Main simulation logic */

document.getElementById('runBtn').addEventListener('click', runSim);
document.getElementById('clearBtn').addEventListener('click', clearAll);

function runSim(){
  const n = Math.max(1, parseInt(document.getElementById('nInput').value));
  const m = Math.max(1, parseInt(document.getElementById('mInput').value));
  const p = Math.min(1, Math.max(0, parseFloat(document.getElementById('pInput').value)));
  const q = 1 - p;
  const cap = Math.max(1, parseInt(document.getElementById('capInput').value));

  // Prepare final counts for k=0..n (k = number of secure weeks)
  const countsK = new Array(n+1).fill(0);

  // Trajectories data: only store running cumulative for selected number of plotted trajectories
  const plotCap = Math.min(cap, m);
  const plotArrays = []; // each is array length n
  for (let i=0;i<plotCap;i++) plotArrays.push(new Array(n).fill(0));

  // Also compute mean and var of final scores
  let sumFinal = 0;
  let sumFinalSq = 0;

  // Run m simulated trajectories
  for (let i=0;i<m;i++){
    let cum = 0;
    let secureCount = 0;
    // fill small array for this path if needed
    const rec = (i < plotCap) ? plotArrays[i] : null;
    for (let t=0;t<n;t++){
      const step = bernoulliStep(q); // +1 or -1
      cum += step;
      if (step === 1) secureCount++;
      if (rec) rec[t] = cum;
    }
    // record counts
    countsK[secureCount] += 1;
    sumFinal += cum;
    sumFinalSq += cum*cum;
  }

  // Convert countsK (over k) to counts over S (scores)
  // possible S values: -n, -n+2, ..., n
  const scores = [];
  const empiricalCounts = [];
  for (let k=0;k<=n;k++){
    const S = kToScore(k,n);
    scores.push(S);
    empiricalCounts.push(countsK[k]);
  }

  // Theoretical binomial pmf for k
  const pmfK = binomialPMF(n, q); // length n+1
  const theoryCounts = pmfK.map(pk => pk * m);

  // Compute empirical pmf and theoretical pmf (normalized)
  const empiricalPmf = empiricalCounts.map(c => c / m);
  const theoryPmf = pmfK; // already normalized

  const l1 = l1Distance(empiricalPmf, theoryPmf);

  // Update trajectory chart: plot subset
  // Remove previous datasets and add each trajectory (with low opacity)
  trajChart.data.datasets = [];
  for (let i=0;i<plotArrays.length;i++){
    trajChart.data.datasets.push({
      label: 'traj'+i,
      data: plotArrays[i].map((v, idx) => ({x: idx+1, y: v})),
      borderColor: 'rgba(96,165,250,0.12)',
      borderWidth: 1,
      pointRadius: 0,
      fill: false,
      tension: 0.2
    });
  }
  // Add bold empirical mean-of-trajectories line (mean cumulative across plotted trajectories? better: theoretical expected path)
  // The expected cumulative score at time t is E[S_t] = t*(2q - 1)
  const expectedPath = [];
  for (let t=1;t<=n;t++) expectedPath.push({x:t, y:t*(2*q - 1)});
  trajChart.data.datasets.push({
    label: 'Expected path (mean)',
    data: expectedPath,
    borderColor: 'rgba(34,197,94,1)',
    borderWidth: 2,
    pointRadius: 0,
    fill:false,
    tension:0.2
  });

  trajChart.update();

  // Update histogram chart: labels = scores, dataset[0]=empiricalCounts, dataset[1]=theoryCounts
  histChart.data.labels = scores.map(s => s.toString());
  histChart.data.datasets[0].data = empiricalCounts;
  // For the line dataset we need same-length array (theoryCounts)
  histChart.data.datasets[1].data = theoryCounts;
  histChart.update();

  // Update stats badges
  const meanFinal = sumFinal / m;
  const varFinal = (sumFinalSq / m) - (meanFinal*meanFinal);
  document.getElementById('meanBadge').textContent = `Empirical mean final score: ${meanFinal.toFixed(4)}`;
  document.getElementById('varBadge').textContent = `Empirical var final score: ${varFinal.toFixed(4)}`;
  document.getElementById('distBadge').textContent = `L1 distance (empirical vs theory): ${l1.toExponential(3)}`;

  // Info text
  document.getElementById('histInfo').innerHTML =
    `<strong>Parameters:</strong> n=${n}, m=${m}, breach p=${p.toFixed(3)}, secure q=${q.toFixed(3)}.<br>` +
    `Score bins: ${scores[0]} .. ${scores[scores.length-1]} (step 2).<br>` +
    `Theoretical counts are m¬∑Binomial(n,q). L1 distance shown above quantifies empirical-theory mismatch (‚Üí0 as m‚Üë).`;
}

function clearAll(){
  // clear charts and badges
  trajChart.data.datasets = [];
  trajChart.update();
  histChart.data.labels = [];
  histChart.data.datasets[0].data = [];
  histChart.data.datasets[1].data = [];
  histChart.update();
  document.getElementById('meanBadge').textContent = 'Empirical mean final score: ‚Äî';
  document.getElementById('varBadge').textContent = 'Empirical var final score: ‚Äî';
  document.getElementById('distBadge').textContent = 'L1 distance to theory: ‚Äî';
  document.getElementById('histInfo').textContent = '';
}
</script>
